
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/murphy214/gotile/gotile/db_interface.go (34.1%)</option>
				
				<option value="file1">github.com/murphy214/gotile/gotile/envelope.go (52.3%)</option>
				
				<option value="file2">github.com/murphy214/gotile/gotile/geojson.go (0.0%)</option>
				
				<option value="file3">github.com/murphy214/gotile/gotile/geometry.go (72.4%)</option>
				
				<option value="file4">github.com/murphy214/gotile/gotile/line_envelope.go (47.3%)</option>
				
				<option value="file5">github.com/murphy214/gotile/gotile/output.go (0.0%)</option>
				
				<option value="file6">github.com/murphy214/gotile/gotile/poly_envelope.go (98.9%)</option>
				
				<option value="file7">github.com/murphy214/gotile/gotile/tile.go (66.7%)</option>
				
				<option value="file8">github.com/murphy214/gotile/gotile/util.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package tile_surge

import (
        //"github.com/golang/protobuf/proto"
        "fmt"
        "github.com/jackc/pgx"
        _ "github.com/lib/pq"
        m "github.com/murphy214/mercantile"
        pc "github.com/murphy214/polyclip"
        "github.com/paulmach/go.geojson"
        "strconv"
        "strings"
        "sort"
        //"sync"
)

// returns the bbox logic from a table name and tileid
func Add_BBox(tablename string, tileid m.TileID) string <span class="cov8" title="1">{
        bds := m.Bounds(tileid)

        return fmt.Sprintf("(%s.geom &amp;&amp; ST_MakeEnvelope(%f, %f, %f, %f, 4326))", tablename, bds.W, bds.S, bds.E, bds.N)

}</span>

// this function allows you interface with a postgis database
// it create a raw feature collection geojson representation
// which would be the same if you were just reading from a geojson
func DB_Interface(database string, query string) *geojson.FeatureCollection <span class="cov0" title="0">{
        // intializing the config
        a := pgx.ConnPoolConfig{
                ConnConfig: pgx.ConnConfig{
                        Host:     "localhost",
                        Port:     5432,
                        Database: database,
                        User:     "postgres",
                },
                MaxConnections: 1,
        }

        // creating the connection
        p, _ := pgx.NewConnPool(a)

        // executing the query
        rows, _ := p.Query(query)

        // getting keys
        var keys []string
        fdescs := rows.FieldDescriptions()
        for _, i := range fdescs </span><span class="cov0" title="0">{
                keys = append(keys, i.Name)
        }</span>

        <span class="cov0" title="0">pos := len(keys) - 1
        featcollection := &amp;geojson.FeatureCollection{}

        // iterating through each row of the queried data
        for rows.Next() </span><span class="cov0" title="0">{
                // creating properties map
                var geometry geojson.Geometry

                vals, _ := rows.Values()
                tempmap := map[string]interface{}{}
                for ii, i := range vals[:pos] </span><span class="cov0" title="0">{
                        tempmap[keys[ii]] = i
                }</span>
                <span class="cov0" title="0">geometry.Scan(vals[pos])
                feature := geojson.Feature{Geometry: &amp;geometry, Properties: tempmap}
                featcollection.Features = append(featcollection.Features, &amp;feature)</span>


        }

        <span class="cov0" title="0">return featcollection</span>
}

// checking number of rows
func checkCount(rows *pgx.Rows) (count int) <span class="cov0" title="0">{
         for rows.Next() </span><span class="cov0" title="0">{
            rows.Scan(&amp;count)
    }</span>   
    <span class="cov0" title="0">return count</span>
}


// getting the extent of a given database
func Get_Extent(database string,tablename string) (m.Extrema,int) <span class="cov0" title="0">{
        sqlquery := fmt.Sprintf("SELECT ST_Extent(geom) as table_extent FROM %s;",tablename)

        // intializing the config
        a := pgx.ConnPoolConfig{
                ConnConfig: pgx.ConnConfig{
                        Host:     "localhost",
                        Port:     5432,
                        Database: database,
                        User:     "postgres",
                },
                MaxConnections: 1,
        }

        // creating the connection
        p, _ := pgx.NewConnPool(a)

        rows, _ := p.Query(sqlquery)
        var bbox string
        for rows.Next() </span><span class="cov0" title="0">{
                vals, _ := rows.Values()
                bbox = vals[0].(string)
        }</span>
        <span class="cov0" title="0">bbox = bbox[4:len(bbox) - 1]
        bbox = strings.Replace(bbox,","," ",1)
        vals := strings.Split(bbox," ")
        west,_ := strconv.ParseFloat(vals[0],64)
        south,_ := strconv.ParseFloat(vals[1],64)
        east,_ := strconv.ParseFloat(vals[2],64)
        north,_ := strconv.ParseFloat(vals[3],64)

    rows, _ = p.Query(fmt.Sprintf("SELECT COUNT(*) as count FROM  %s",tablename))
         countrows := checkCount(rows)

        return m.Extrema{N:north,S:south,E:east,W:west},countrows</span>
}


// evavulate extrema
func Lint_Extrema(ext m.Extrema,minzoom int) m.Extrema <span class="cov8" title="1">{
        // getting en
        en := []float64{ext.E,ext.N}
        en_tile := m.Tile(en[0],en[1],minzoom)
        en_bounds := m.Bounds(en_tile) 
        ext.N = en_bounds.N
        ext.E = en_bounds.E

        // getting ws
        ws := []float64{ext.W,ext.S}
        ws_tile := m.Tile(ws[0],ws[1],minzoom)
        ws_bounds := m.Bounds(ws_tile) 
        ext.S = ws_bounds.S
        ext.W = ws_bounds.W

        return ext
}</span>

// making the tilemap for each tileslice in a given row
func Make_Tilelist(ext m.Extrema,minzoom int) []m.TileID <span class="cov8" title="1">{
        // getting linted extrema
        ext = Lint_Extrema(ext,minzoom)
        
        tileid := m.Tile(ext.W,ext.S,minzoom)
        bds := m.Bounds(tileid)
        startpt := []float64{(bds.E+bds.W)/2.0,(bds.N+bds.S)/2.0}
        currenty := startpt[1]
        currentx := startpt[0]
        startx := startpt[0]
        size := pc.Point{bds.E-bds.W,bds.N-bds.S}
        tilelist := []m.TileID{}


        for currenty &lt; ext.N </span><span class="cov8" title="1">{
                currentx = startx
                for currentx &lt; ext.E </span><span class="cov8" title="1">{
                        tileid := m.Tile(currentx,currenty,minzoom)
                        tilelist = append(tilelist,tileid)
                        currentx += size.X
                }</span>
                <span class="cov8" title="1">currenty += size.Y</span>
        }
        <span class="cov8" title="1">return tilelist</span>

}

// type for creating upper zoom data sets
type Extent struct {
        Bds m.Extrema
        Area float64
        Unique interface{}
}

// getting teh database extents
func DB_Extents(database string,tablename string,uniquefield string) []Extent <span class="cov0" title="0">{
        sqlquery := fmt.Sprintf("SELECT %s,ST_AsGeoJSON(ST_Envelope(geom)) FROM %s;",uniquefield,tablename)

        // intializing the config
        a := pgx.ConnPoolConfig{
                ConnConfig: pgx.ConnConfig{
                        Host:     "localhost",
                        Port:     5432,
                        Database: database,
                        User:     "postgres",
                },
                MaxConnections: 1,
        }

        // creating the connection
        p, _ := pgx.NewConnPool(a)

        rows, _ := p.Query(sqlquery)
        //var bbox string
        var id interface{} 
        var geom geojson.Geometry
        extents := []Extent{}
        for rows.Next() </span><span class="cov0" title="0">{
                vals,_ := rows.Values()
                geom.Scan(vals[1])

                id = vals[0]
                //bbox = vals[0].(string)
                val := geom.Polygon[0]
                bds := m.Extrema{S:val[0][1],N:val[1][1],W:val[0][0],E:val[2][0]}

                area := (bds.N - bds.S) * (bds.E - bds.W)
                extents = append(extents,Extent{Bds:bds,Area:area,Unique:id})

        }</span>
        <span class="cov0" title="0">sort.Slice(extents, func(i, j int) bool </span><span class="cov0" title="0">{ return extents[i].Area &gt; extents[j].Area }</span>)

        <span class="cov0" title="0">return extents</span>
}






</pre>
		
		<pre class="file" id="file1" style="display: none">package tile_surge

import (
        //l "github.com/murphy214/layersplit"
        m "github.com/murphy214/mercantile"
        //pc "github.com/murphy214/polyclip"
        "github.com/paulmach/go.geojson"
        //"strings"
        "fmt"
        "database/sql"
        "math"
        //"log"
        //"sync"
)

// makes a tilemap and returns
func Make_Tilemap(feats *geojson.FeatureCollection, size int) (map[m.TileID][]*geojson.Feature,int) <span class="cov8" title="1">{
        c := make(chan map[m.TileID][]*geojson.Feature)
        for _, i := range feats.Features </span><span class="cov8" title="1">{
                partmap := map[m.TileID][]*geojson.Feature{}

                go func(i *geojson.Feature, size int, c chan map[m.TileID][]*geojson.Feature) </span><span class="cov8" title="1">{
                        //partmap := map[m.TileID][]*geojson.Feature{}

                        if i.Geometry.Type == "Polygon" </span><span class="cov8" title="1">{
                                partmap = Env_Polygon(i, size)
                        }</span><span class="cov0" title="0"> else if i.Geometry.Type == "LineString" </span><span class="cov0" title="0">{
                                partmap = Env_Line(i, size)
                        }</span><span class="cov0" title="0"> else if i.Geometry.Type == "Point" </span><span class="cov0" title="0">{
                                pt := i.Geometry.Point
                                tileid := m.Tile(pt[0], pt[1], size)
                                partmap[tileid] = append(partmap[tileid], i)
                        }</span>
                        <span class="cov8" title="1">c &lt;- partmap</span>
                }(i, size, c)
        }

        // collecting channel shit
        <span class="cov8" title="1">totalmap := map[m.TileID][]*geojson.Feature{}
        for range feats.Features </span><span class="cov8" title="1">{
                partmap := &lt;-c
                for k, v := range partmap </span><span class="cov8" title="1">{
                        totalmap[k] = append(totalmap[k], v...)
                }</span>
        }

        // getting size of total number of features within the tilemap
        <span class="cov8" title="1">totalsize := 0
        for _,v := range totalmap </span><span class="cov8" title="1">{
                totalsize += len(v)
        }</span>



        <span class="cov8" title="1">return totalmap,totalsize</span>
}

// rounds a number to an adequate value 
func Round(val float64, roundOn float64, places int ) (newVal float64) <span class="cov0" title="0">{
        var round float64
        pow := math.Pow(10, float64(places))
        digit := pow * val
        _, div := math.Modf(digit)
        if div &gt;= roundOn </span><span class="cov0" title="0">{
                round = math.Ceil(digit)
        }</span><span class="cov0" title="0"> else {
                round = math.Floor(digit)
        }</span>
        <span class="cov0" title="0">newVal = round / pow
        return</span>
}

// calculates the maximum amount of concurrent actions that can be performed in memory 
func Size_Stovepipe(config Config) int <span class="cov0" title="0">{
        // getting the delta between the zooms 
        delta := config.Maxzoom - config.Currentzoom - 1

        // getting the number of go routines
        number_go_routines := math.Pow(4.0,float64(delta))

        // assuming 10 kb per go routine
        size_each_routine := float64(4) // kb

        // estimated or maximum memory within stovepipe
        size_stovepipe := number_go_routines * size_each_routine + float64(config.Number_Features) * float64(4)

        // getting the size of a gb
        size_gb := size_stovepipe / 1000.0 / 1000.0

        // getting the number of sem things to make
        size_sem := int(Round(config.Memory / size_gb,.5,0))
        return size_sem

}</span>

// makes children and returns tilemap of a first intialized tilemap
func Make_Tilemap_Children(tilemap map[m.TileID][]*geojson.Feature, prefix string) (map[m.TileID][]*geojson.Feature,int) <span class="cov8" title="1">{

        // iterating through each tileid
        ccc := make(chan map[m.TileID][]*geojson.Feature)
        newmap := map[m.TileID][]*geojson.Feature{}
        count2 := 0
        counter := 0
        sizetilemap := len(tilemap)
        buffer := 100000

        // iterating through each tielmap
        for k, v := range tilemap </span><span class="cov8" title="1">{
                go func(k m.TileID, v []*geojson.Feature, ccc chan map[m.TileID][]*geojson.Feature) </span><span class="cov8" title="1">{
                        cc := make(chan map[m.TileID][]*geojson.Feature)
                        for _, i := range v </span><span class="cov8" title="1">{
                                go func(k m.TileID, i *geojson.Feature, cc chan map[m.TileID][]*geojson.Feature) </span><span class="cov8" title="1">{
                                        if i.Geometry.Type == "Polygon" </span><span class="cov8" title="1">{
                                                cc &lt;- Children_Polygon(i, k)
                                        }</span><span class="cov0" title="0"> else if i.Geometry.Type == "LineString" </span><span class="cov0" title="0">{
                                                partmap := Env_Line(i, int(k.Z+1))
                                                partmap = Lint_Children_Lines(partmap, k)
                                                cc &lt;- partmap
                                        }</span><span class="cov0" title="0"> else if i.Geometry.Type == "Point" </span><span class="cov0" title="0">{
                                                partmap := map[m.TileID][]*geojson.Feature{}
                                                pt := i.Geometry.Point
                                                tileid := m.Tile(pt[0], pt[1], int(k.Z+1))
                                                partmap[tileid] = append(partmap[tileid], i)
                                                cc &lt;- partmap
                                        }</span>
                                }(k, i, cc)
                        }

                        // collecting all into child map
                        <span class="cov8" title="1">childmap := map[m.TileID][]*geojson.Feature{}
                        for range v </span><span class="cov8" title="1">{
                                tempmap := &lt;-cc
                                for k, v := range tempmap </span><span class="cov8" title="1">{
                                        childmap[k] = append(childmap[k], v...)
                                }</span>
                        }

                        <span class="cov8" title="1">ccc &lt;- childmap</span>
                }(k, v, ccc)

                <span class="cov8" title="1">counter += 1
                // collecting shit
                if (counter == buffer) || (sizetilemap-1 == count2) </span><span class="cov8" title="1">{
                        count := 0

                        for count &lt; counter </span><span class="cov8" title="1">{
                                tempmap := &lt;-ccc
                                for k, v := range tempmap </span><span class="cov8" title="1">{
                                        newmap[k] = append(newmap[k], v...)
                                }</span>
                                <span class="cov8" title="1">count += 1</span>
                        }
                        <span class="cov8" title="1">counter = 0
                        fmt.Printf("\r[%d / %d] Tiles Complete, Size: %d       ", count2, sizetilemap, int(k.Z)+1)</span>

                }
                <span class="cov8" title="1">count2 += 1</span>

        }


        // getting size of total number of features within the tilemap
        <span class="cov8" title="1">totalsize := 0
        for _,v := range newmap </span><span class="cov8" title="1">{
                totalsize += len(v)
        }</span>



        <span class="cov8" title="1">return newmap,totalsize</span>
}


// makes children and returns tilemap of a first intialized tilemap
func Intialize_Drill(tilemap map[m.TileID][]*geojson.Feature,config Config, db *sql.DB) []Vector_Tile <span class="cov0" title="0">{
        // getting size sema (i.e. the limitation on how many go functions are called )
        // in the routine below, calculated by teh memory input config
        size_sem := Size_Stovepipe(config)
        if size_sem == 0 </span><span class="cov0" title="0">{
                size_sem = 1
        }</span>
        <span class="cov0" title="0">fmt.Printf("Max Make_Zoom_Drill Go Routines: %d\n",size_sem)

        // creating sema
        var sema = make(chan struct{}, size_sem)

        // intializing values        
        prefix := config.Prefix
        endsize := config.Maxzoom
        count2 := 0
        sizetilemap := len(tilemap)
        //var wg sync.WaitGroup
        count := 0
        c := make(chan []Vector_Tile)
        for k, v := range tilemap </span><span class="cov0" title="0">{

                go func(k m.TileID, v []*geojson.Feature,c chan []Vector_Tile) </span><span class="cov0" title="0">{

                        sema &lt;- struct{}{}        // acquire token
                        defer func() </span><span class="cov0" title="0">{ &lt;-sema }</span>() // release token
                        <span class="cov0" title="0">c &lt;- Make_Zoom_Drill(k, v, prefix, endsize,config)
                        fmt.Printf("[%d / %d] Tiles Recursively Drilled to endsize, %d\n", count2, sizetilemap, endsize)
                        count2 += 1</span>
                }(k, v,c)



                <span class="cov0" title="0">count +=1</span> 
        }
        //wg.Wait()

        <span class="cov0" title="0">total := 0
        // iterating through each value in the tilemap
        totalvts := []Vector_Tile{}
        for range tilemap </span><span class="cov0" title="0">{
                vts := &lt;- c
                total += len(vts)
                if config.Type == "mbtiles" </span><span class="cov0" title="0">{
                        Insert_Data3(vts,db)

                }</span><span class="cov0" title="0"> else if config.Type == "json" </span><span class="cov0" title="0">{
                        totalvts = append(totalvts,vts...)
                }</span>
                <span class="cov0" title="0">fmt.Printf("\nTotal Number of Tiles %d\n",total)</span>

        }
        <span class="cov0" title="0">return totalvts</span>
}


// vector tile struct 
type Vector_Tile struct {
        Filename string
        Data []byte
        Tileid m.TileID
}

// recursively drills until the max zoom is reached
func Make_Zoom_Drill(k m.TileID, v []*geojson.Feature, prefix string, endsize int,config Config) []Vector_Tile <span class="cov8" title="1">{
        outputsize := int(k.Z) + 1
        cc := make(chan map[m.TileID][]*geojson.Feature)
        for _, i := range v </span><span class="cov8" title="1">{
                go func(k m.TileID, i *geojson.Feature, cc chan map[m.TileID][]*geojson.Feature) </span><span class="cov8" title="1">{
                        if i.Geometry.Type == "Polygon" </span><span class="cov8" title="1">{
                                partmap := Children_Polygon(i, k) 
                                cc &lt;- partmap
                        }</span><span class="cov0" title="0"> else if i.Geometry.Type == "LineString" </span><span class="cov0" title="0">{
                                partmap := Env_Line(i, int(k.Z+1))
                                partmap = Lint_Children_Lines(partmap, k)
                                cc &lt;- partmap
                        }</span><span class="cov0" title="0"> else if i.Geometry.Type == "Point" </span><span class="cov0" title="0">{
                                partmap := map[m.TileID][]*geojson.Feature{}
                                pt := i.Geometry.Point
                                tileid := m.Tile(pt[0], pt[1], int(k.Z+1))
                                partmap[tileid] = append(partmap[tileid], i)
                                cc &lt;- partmap
                        }</span>
                }(k, i, cc)
        }

        // collecting all into child map
        <span class="cov8" title="1">childmap := map[m.TileID][]*geojson.Feature{}
        for range v </span><span class="cov8" title="1">{
                partmap := &lt;-cc
                for kk, vv := range partmap </span><span class="cov8" title="1">{
                        childmap[kk] = append(childmap[kk], vv...)
                }</span>
        }

        // iterating through each value in the child map and waiting to complete
        //var wg sync.WaitGroup
        <span class="cov8" title="1">vtchan := make(chan Vector_Tile)
        for kkk, vvv := range childmap </span><span class="cov8" title="1">{
                //childmap = map[m.TileID][]*geojson.Feature{}
                //wg.Add(1)
                go func(kkk m.TileID, vvv []*geojson.Feature, prefix string,vtchan chan Vector_Tile) </span><span class="cov8" title="1">{
                        vtchan &lt;- Make_Tile(kkk, vvv, prefix,config)
                                //Make_Zoom_Drill(kkk, vvv, prefix, endsize)
                        //wg.Done()

                }</span>(kkk, vvv, prefix,vtchan)
        }
        
        <span class="cov8" title="1">vector_tiles := []Vector_Tile{}
        for range childmap </span><span class="cov8" title="1">{
                vt := &lt;-vtchan
                vector_tiles = append(vector_tiles,vt)
        }</span>

        //wg.Wait()
        <span class="cov8" title="1">if endsize != outputsize </span><span class="cov8" title="1">{
                ccc := make(chan []Vector_Tile)
                for kkk, vvv := range childmap </span><span class="cov8" title="1">{
                        go func(kkk m.TileID, vvv []*geojson.Feature, prefix string,ccc chan []Vector_Tile) </span><span class="cov8" title="1">{
                                ccc &lt;- Make_Zoom_Drill(kkk,vvv,prefix,endsize,config)
                        }</span>(kkk,vvv,prefix,ccc)
                }
                // appending to the major vector tiles shit
                <span class="cov8" title="1">for range childmap </span><span class="cov8" title="1">{
                        vts := &lt;- ccc
                        vector_tiles = append(vector_tiles,vts...)
                }</span>
                <span class="cov8" title="1">return vector_tiles</span>

        }<span class="cov8" title="1"> else {
                return vector_tiles
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package tile_surge

import (
        //l "github.com/murphy214/layersplit"
        "fmt"
        m "github.com/murphy214/mercantile"
        "github.com/paulmach/go.geojson"
        "io/ioutil"
        //"sync"
        "time"
        "database/sql"

)


// Lints properties within multigeometies
func Lint_Properties(props map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        newprops := map[string]interface{}{}
        for k,v := range props </span><span class="cov0" title="0">{
                if k != "id" </span><span class="cov0" title="0">{
                        newprops[k] = v
                }</span>
        }
        <span class="cov0" title="0">return newprops</span>
}

// Splits multiple geometries into single geoemetries
func Split_Multi(gjson *geojson.FeatureCollection) *geojson.FeatureCollection <span class="cov0" title="0">{
        // splitting multi geometriess
        c := make(chan []*geojson.Feature)
        for _,i := range gjson.Features </span><span class="cov0" title="0">{
                go func(i *geojson.Feature,c chan []*geojson.Feature) </span><span class="cov0" title="0">{
                        if i.Geometry.Type == "MultiLineString" </span><span class="cov0" title="0">{
                                props := i.Properties
                                props = Lint_Properties(props)
                                newfeats := []*geojson.Feature{}
                                for _,newline := range i.Geometry.MultiLineString </span><span class="cov0" title="0">{
                                        newfeats = append(newfeats,&amp;geojson.Feature{Geometry:&amp;geojson.Geometry{LineString:newline,Type:"LineString"},Properties:props})
                                }</span>

                                <span class="cov0" title="0">c &lt;- newfeats</span>
                        }<span class="cov0" title="0"> else if i.Geometry.Type == "MultiPolygon" </span><span class="cov0" title="0">{
                                props := i.Properties
                                props = Lint_Properties(props)

                                newfeats := []*geojson.Feature{}
                                for _,newline := range i.Geometry.MultiPolygon </span><span class="cov0" title="0">{
                                        newfeats = append(newfeats,&amp;geojson.Feature{Geometry:&amp;geojson.Geometry{Polygon:newline,Type:"Polygon"},Properties:props})
                                }</span>
                                <span class="cov0" title="0">c &lt;- newfeats</span>
                        }<span class="cov0" title="0"> else if i.Geometry.Type == "MultiPoint" </span><span class="cov0" title="0">{
                                props := i.Properties

                                props = Lint_Properties(props)

                                newfeats := []*geojson.Feature{}
                                for _,newline := range i.Geometry.MultiPoint </span><span class="cov0" title="0">{
                                        newfeats = append(newfeats,&amp;geojson.Feature{Geometry:&amp;geojson.Geometry{Point:newline,Type:"Point"},Properties:props})
                                }</span>
                                <span class="cov0" title="0">c &lt;- newfeats</span>
                        }<span class="cov0" title="0"> else {
                                i.Properties = Lint_Properties(i.Properties)

                                c &lt;- []*geojson.Feature{i}
                        }</span>
                }(i,c)
        }
        <span class="cov0" title="0">newfeats := []*geojson.Feature{}
        for range gjson.Features </span><span class="cov0" title="0">{
                newfeats = append(newfeats,&lt;-c...)
        }</span>        
        <span class="cov0" title="0">return &amp;geojson.FeatureCollection{Features:newfeats}</span>
} 



// reads geojson feature collection into memory
func Read_Geojson(filename string) *geojson.FeatureCollection <span class="cov0" title="0">{
        e, _ := ioutil.ReadFile(filename)
        fc1, _ := geojson.UnmarshalFeatureCollection(e)
        return fc1
}</span>

// upper zoom configuration for sql shit
type Upper_Zoom_Config struct {
        Unique string // unique field
        Zoom_Map map[int]float64
}

// Configuration shit
type Config struct {
        Type string // json or mbtiles
        Minzoom int // minimum zoom
        Maxzoom int // maximum zoom
        Number_Features int // number of features (not needed)
        Prefix string // prefix
        Zooms []int // zooms (not needed)
        Currentzoom int // current zoom (not needed)
        Outputjsonfilename string // output json filename (not needed)
        Outputmbtilesfilename string // output mbtiles filename (not needed)
        Memory float64 // memory (not needed)
        Zoom_Config Upper_Zoom_Config // zoom config (currently not used)
}

// epands the configuration structure
func Expand_Config(config Config) Config <span class="cov0" title="0">{
        count := config.Minzoom
        zooms := []int{}
        for count &lt;= config.Maxzoom </span><span class="cov0" title="0">{
                zooms = append(zooms,count)
                count += 1
        }</span>
        <span class="cov0" title="0">config.Memory = 2.5
        config.Zooms = zooms
        config.Outputjsonfilename = config.Prefix + ".json"
        config.Outputmbtilesfilename = config.Prefix + ".mbtiles"
        return config</span>
}

// creates the tiles from a given configuration
func Make_Tiles(gjson *geojson.FeatureCollection, config Config) <span class="cov0" title="0">{
        // Splittng multiple geometries
        gjson = Split_Multi(gjson)


        // creating config expansion
        config = Expand_Config(config)
        fmt.Print("Writing Layers ", config.Zooms, "\n")

        // reading geojson
        var db *sql.DB
        if config.Type == "mbtiles" </span><span class="cov0" title="0">{
                db = Create_Database_Meta(config,gjson.Features[0])
        }</span>


        <span class="cov0" title="0">s := time.Now()

        // iterating through each zoom
        // creating tilemap
        // getting prefix and min zooom 
        prefix := config.Prefix
        config.Currentzoom = config.Minzoom

        // creating totalmap for tiles under 5 
        // any tiles under 5 arent worth recursively drilling
        totalmap := map[m.TileID]Vector_Tile{}
        tilemap := map[m.TileID][]*geojson.Feature{}
        totalsize := 0
        for (config.Currentzoom &lt;= 5) || (config.Currentzoom == config.Minzoom) </span><span class="cov0" title="0">{
                // creating tile map for current layer
                if config.Currentzoom == config.Minzoom </span><span class="cov0" title="0">{
                        tilemap,totalsize = Make_Tilemap(gjson, config.Currentzoom)
                }</span><span class="cov0" title="0"> else {
                        tilemap,totalsize = Make_Tilemap_Children(tilemap, prefix)
                }</span>

                <span class="cov0" title="0">c := make(chan Vector_Tile)
                for k, v := range tilemap </span><span class="cov0" title="0">{
                        go func(k m.TileID, v []*geojson.Feature, prefix string,c chan Vector_Tile) </span><span class="cov0" title="0">{
                                c &lt;- Make_Tile(k, v, prefix,config)
                        }</span>(k, v, prefix,c)
                }

                // iterating through tile map
                <span class="cov0" title="0">for range tilemap </span><span class="cov0" title="0">{
                        v := &lt;- c
                        totalmap[v.Tileid] = v
                }</span>

                // incrementing the current zoom 
                <span class="cov0" title="0">config.Currentzoom = config.Currentzoom + 1</span>
        }

        // number of features
        <span class="cov0" title="0">config.Number_Features = totalsize

        // drilling if needed
        // sending the tilemap into the driller
        if config.Type == "mbtiles" </span><span class="cov0" title="0">{
                db = Insert_Data2(totalmap,db)
        }</span>

        // drilling down tilemap
        <span class="cov0" title="0">totalvts := Intialize_Drill(tilemap,config,db)

        // sending into the correct function for output type\
        if config.Type == "json" </span><span class="cov0" title="0">{
                // adding totalvts to the totalmap
                for _,i := range totalvts </span><span class="cov0" title="0">{
                        totalmap[i.Tileid] = i
                }</span>

                <span class="cov0" title="0">Write_Json(totalmap,config.Outputjsonfilename)</span>
        }<span class="cov0" title="0"> else if config.Type == "mbtiles" </span><span class="cov0" title="0">{
                Make_Index(db)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nCompleted in %s.\n", time.Now().Sub(s))</span>
}

// makes a sql query for a tile specific query at the first zoom level
// this function will then iteratively go through each query based on a rough memory calculation
// to estimate how many top level routines can be throughput at once
func Make_Bounds_Sql(database string,tablename string,basesql string,config Config) <span class="cov0" title="0">{
        s := time.Now()
        // getting the extent and number of rows
        ext,num_b := Get_Extent(database,tablename)

        // getting the config shit
        config = Expand_Config(config)
        config.Currentzoom = config.Minzoom
        fmt.Print("Writing Layers ", config.Zooms, "\n")

        // getting json sample
        gjson := DB_Interface(database,basesql + " LIMIT 1;")

        // reading geojson
        var db *sql.DB
        if config.Type == "mbtiles" </span><span class="cov0" title="0">{
                db = Create_Database_Meta(config,gjson.Features[0])
        }</span>

        // getting the total map for the upper zomos
        //totalmap := map[m.TileID]Vector_Tile{}


        <span class="cov0" title="0">config.Number_Features = num_b

        // getting the sema size
        sema_size_sql := Size_Stovepipe(config) 
        fmt.Printf("Max Make_Tiles_Sql Go Routines: %d\n",sema_size_sql)

        // creating sema
        var sema_sql = make(chan struct{}, sema_size_sql)

        // getting the tile list
        tilelist := Make_Tilelist(ext,config.Currentzoom)
        count := 0
        // iterating through each tile in the tilelist
        if config.Maxzoom &gt; config.Currentzoom </span><span class="cov0" title="0">{
                c := make(chan []Vector_Tile) 
                sizetilelist := len(tilelist)
                for _,i := range tilelist </span><span class="cov0" title="0">{
                        go func(i m.TileID,c chan []Vector_Tile) </span><span class="cov0" title="0">{
                                sema_sql &lt;- struct{}{}        // acquire token
                                defer func() </span><span class="cov0" title="0">{ &lt;-sema_sql }</span>() // release token
                                <span class="cov0" title="0">count += 1
                                fmt.Printf("\n[%d/%d] Sql Tiles Started.\n",count,sizetilelist)

                                // getting query logic
                                bbox_logic := Add_BBox(tablename,i)
                                one_query := fmt.Sprintf("%s WHERE %s",basesql,bbox_logic)
                                
                                // selecint data and piping to channel
                                //DB_Interface(database,one_query).Features
                                c &lt;-Make_Zoom_Drill(i, DB_Interface(database,one_query).Features, config.Prefix, config.Maxzoom,config)</span>
                        }(i,c)
                }

                // iterating over tilelist
                <span class="cov0" title="0">for range tilelist </span><span class="cov0" title="0">{
                        vtmap := &lt;-c
                        Insert_Data3(vtmap,db)
                }</span>
        }

        // finishing creation of output type
        <span class="cov0" title="0">if config.Type == "json" </span><span class="cov0" title="0">{
                //Write_Json(totalmap,config.Outputjsonfilename)
        }</span><span class="cov0" title="0"> else if config.Type == "mbtiles" </span><span class="cov0" title="0">{
                Make_Index(db)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Time creating mbtiles %s.\n",time.Now().Sub(s))</span>
}

</pre>
		
		<pre class="file" id="file3" style="display: none">package tile_surge

import (
        m "github.com/murphy214/mercantile"
        "math"
        //pc "github.com/murphy214/polyclip"
)


type Cursor struct {
        Geometry []uint32
        LastPoint []int32
        Bounds m.Extrema
        DeltaX float64 // delta between bounds
        DeltaY float64 // delta between bounds
        Count uint32
}

const mercatorPole = 20037508.34

func Convert_Point(point []float64) []float64 <span class="cov8" title="1">{
        x := mercatorPole / 180.0 * point[0]

        y := math.Log(math.Tan((90.0+point[1])*math.Pi/360.0)) / math.Pi * mercatorPole
        y = math.Max(-mercatorPole, math.Min(y, mercatorPole))
        return []float64{x,y}
}</span>


func cmdEnc(id uint32, count uint32) uint32 <span class="cov8" title="1">{
        return (id &amp; 0x7) | (count &lt;&lt; 3)
}</span>

func moveTo(count uint32) uint32 <span class="cov8" title="1">{
        return cmdEnc(1, count)
}</span>

func lineTo(count uint32) uint32 <span class="cov8" title="1">{
        return cmdEnc(2, count)
}</span>

func closePath(count uint32) uint32 <span class="cov8" title="1">{
        return cmdEnc(7, count)
}</span>

func paramEnc(value int32) int32 <span class="cov8" title="1">{
        return (value &lt;&lt; 1) ^ (value &gt;&gt; 31)
}</span>        

func (cur Cursor) MovePoint(point []int32) Cursor <span class="cov8" title="1">{
        cur.Geometry = append(cur.Geometry, moveTo(1))
        cur.Geometry = append(cur.Geometry, uint32(paramEnc(point[0]-cur.LastPoint[0])))
        cur.Geometry = append(cur.Geometry, uint32(paramEnc(point[1]-cur.LastPoint[1])))
        cur.LastPoint = point
        return cur
}</span>

func (cur Cursor) LinePoint(point []int32) Cursor <span class="cov8" title="1">{
        deltax := point[0]-cur.LastPoint[0]
        deltay := point[1]-cur.LastPoint[1]
        if ((deltax == 0) &amp;&amp; (deltay == 0)) == false </span><span class="cov8" title="1">{
                cur.Geometry = append(cur.Geometry, uint32(paramEnc(deltax)))
                cur.Geometry = append(cur.Geometry, uint32(paramEnc(deltay)))
                cur.Count = cur.Count + 1
        }</span>
        <span class="cov8" title="1">cur.LastPoint = point
        return cur</span>
}

// makes a line pretty neatly 
func (cur Cursor) Make_Line(coords [][]int32) []uint32 <span class="cov8" title="1">{
        // applying the first move to point
        cur = cur.MovePoint(coords[0])
        cur.Geometry = append(cur.Geometry, lineTo(uint32(len(coords)-1)))

        // iterating through each point
        for _,point := range coords[1:] </span><span class="cov8" title="1">{
                cur = cur.LinePoint(point)
        }</span>

        <span class="cov8" title="1">cur.Geometry[3] = lineTo(cur.Count)

        return cur.Geometry</span>

}

// makes a line pretty neatly 
func (cur Cursor) Make_Line_Float(coords [][]float64) []uint32 <span class="cov8" title="1">{
        // applying the first move to point
        firstpoint := cur.Single_Point(coords[0])
        cur = cur.MovePoint(firstpoint)
        cur.Geometry = append(cur.Geometry, lineTo(uint32(len(coords)-1)))
        // iterating through each point
        for _,point := range coords[1:] </span><span class="cov8" title="1">{
                cur = cur.LinePoint(cur.Single_Point(point))
        }</span>

        <span class="cov8" title="1">cur.Geometry[3] = lineTo(cur.Count)
                
        return cur.Geometry</span>

}


// reverses the coord list
func reverse(coord [][]int32) [][]int32 <span class="cov0" title="0">{
        current := len(coord) - 1
        newlist := [][]int32{}
        for current != -1 </span><span class="cov0" title="0">{
                newlist = append(newlist, coord[current])
                current = current - 1
        }</span>
        <span class="cov0" title="0">return newlist</span>
}

// asserts a winding order
func assert_winding_order(coord [][]int32, exp_orient string) [][]int32 <span class="cov0" title="0">{
        count := 0
        firstpt := coord[0]
        weight := 0.0
        var oldpt []int32
        for _, pt := range coord </span><span class="cov0" title="0">{
                if count == 0 </span><span class="cov0" title="0">{
                        count = 1
                }</span><span class="cov0" title="0"> else {
                        weight += float64((pt[0] - oldpt[0]) * (pt[1] + oldpt[1]))
                }</span>
                <span class="cov0" title="0">oldpt = pt</span>
        }

        <span class="cov0" title="0">weight += float64((firstpt[0] - oldpt[0]) * (firstpt[1] + oldpt[1]))
        var orientation string
        if weight &gt; 0 </span><span class="cov0" title="0">{
                orientation = "clockwise"
        }</span><span class="cov0" title="0"> else {
                orientation = "counter"
        }</span>

        <span class="cov0" title="0">if orientation != exp_orient </span><span class="cov0" title="0">{
                return reverse(coord)
        }</span><span class="cov0" title="0"> else {
                return coord
        }</span>
        <span class="cov0" title="0">return coord</span>

}


// asserts a winding order
func (cur Cursor) Assert_Convert(coord [][]float64, exp_orient string) Cursor <span class="cov8" title="1">{
        count := 0
        firstpt := cur.Single_Point(coord[0])
        weight := 0.0
        var oldpt []int32
        newlist := [][]int32{firstpt}

        // iterating through each float point
        for _, floatpt := range coord </span><span class="cov8" title="1">{
                pt := cur.Single_Point(floatpt)
                newlist = append(newlist,pt)
                if count == 0 </span><span class="cov8" title="1">{
                        count = 1
                }</span><span class="cov8" title="1"> else {
                        weight += float64((pt[0] - oldpt[0]) * (pt[1] + oldpt[1]))
                }</span>
                <span class="cov8" title="1">oldpt = pt</span>
        }

        <span class="cov8" title="1">weight += float64((firstpt[0] - oldpt[0]) * (firstpt[1] + oldpt[1]))
        var orientation string
        if weight &gt; 0 </span><span class="cov8" title="1">{
                orientation = "clockwise"
        }</span><span class="cov8" title="1"> else {
                orientation = "counter"
        }</span>

        <span class="cov8" title="1">if orientation != exp_orient </span><span class="cov0" title="0">{
                newlist = reverse(newlist)
        }</span> 

        <span class="cov8" title="1">newcur := Cursor{LastPoint:cur.LastPoint,Bounds:cur.Bounds,DeltaX:cur.DeltaX,DeltaY:cur.DeltaY}
        newgeom := newcur.Make_Line(newlist)
        newgeom = append(newgeom,closePath(1))
        cur.Geometry = append(cur.Geometry,newgeom...)
        cur.LastPoint = newlist[len(newlist)-1]

        return cur</span>
}


// makes a polygon
func (cur Cursor) Make_Polygon(coords [][][]int32) []uint32 <span class="cov0" title="0">{
        // applying the first ring
        coord := coords[0]
        coord = assert_winding_order(coord, "clockwise")
        cur.Geometry = append(cur.Geometry,cur.Make_Line(coord)...)
        cur.Geometry =  append(cur.Geometry, closePath(1))

        // if multiple rings exist proceed to add those also
        if len(coords) &gt; 1 </span><span class="cov0" title="0">{
                for _,coord := range coords[1:] </span><span class="cov0" title="0">{
                        coord = assert_winding_order(coord, "counter")
                        cur.Geometry = append(cur.Geometry,cur.Make_Line(coord)...)
                        cur.Geometry =  append(cur.Geometry, closePath(1))

                }</span>
        }

        <span class="cov0" title="0">return cur.Geometry</span>
}

// makes a polygon
func (cur Cursor) Make_Polygon_Float(coords [][][]float64) []uint32 <span class="cov8" title="1">{
        // applying the first ring
        cur = cur.Assert_Convert(coords[0],"clockwise")

        // if multiple rings exist proceed to add those also
        if len(coords) &gt; 1 </span><span class="cov8" title="1">{
                for _,coord := range coords[1:] </span><span class="cov8" title="1">{
                        cur = cur.Assert_Convert(coord,"counter")

                }</span>
        }
        <span class="cov8" title="1">return cur.Geometry</span>
}


// converts a single point from a coordinate to a tile point
func (cur Cursor) Single_Point(point []float64) []int32 <span class="cov8" title="1">{
        // converting to sperical coordinates
        point = Convert_Point(point)

        // getting factors to multiply by
        factorx := (point[0] - cur.Bounds.W) / cur.DeltaX
        factory := (cur.Bounds.N - point[1]) / cur.DeltaY

        xval := int32(factorx * 4096)
        yval := int32(factory * 4096)

        if xval &gt;= 4096 </span><span class="cov8" title="1">{
                xval = 4096
        }</span>

        <span class="cov8" title="1">if yval &gt;= 4096 </span><span class="cov8" title="1">{
                yval = 4096
        }</span>

        <span class="cov8" title="1">if xval &lt; 0 </span><span class="cov0" title="0">{
                xval = 0
        }</span>
        <span class="cov8" title="1">if yval &lt; 0 </span><span class="cov0" title="0">{
                yval = 0
        }</span>

        <span class="cov8" title="1">return []int32{xval, yval}</span>
}

func (cur Cursor) Make_Point_Float(point []float64) []uint32 <span class="cov8" title="1">{
        newpoint := cur.Single_Point(point)

        coords := []int32{newpoint[0], newpoint[1]}
        cur.Geometry = []uint32{moveTo(uint32(1))}
        cur = cur.LinePoint(coords)

        return cur.Geometry

}</span>

// converts a cursor to world points
func Convert_Cursor(cur Cursor) Cursor <span class="cov8" title="1">{
        // getting bounds
        bounds := cur.Bounds

        // getting ne point
        en := []float64{bounds.E,bounds.N} // east, north point
        ws := []float64{bounds.W,bounds.S} // west, south point

        // converting these
        en = Convert_Point(en)
        ws = Convert_Point(ws)

        // gettting north east west south
        east := en[0]
        north := en[1]
        west := ws[0]
        south := ws[1]
        bounds = m.Extrema{N:north,E:east,S:south,W:west}

        // getting deltax and deltay
        deltax := east - west
        deltay := north - south

        // setting the new values
        cur.Bounds = bounds
        cur.DeltaX = deltax
        cur.DeltaY = deltay

        return cur
}</span>








</pre>
		
		<pre class="file" id="file4" style="display: none">package tile_surge

import (
        "encoding/json"
        "fmt"
        m "github.com/murphy214/mercantile"
        pc "github.com/murphy214/polyclip"
        "github.com/paulmach/go.geojson"
        "math"
        "sort"
        "strings"
)

// gets the slope of two pc.Points along a line
// if statement logic accounts for undefined corner case
func get_slope2(pt1 pc.Point, pt2 pc.Point) float64 <span class="cov8" title="1">{
        if pt1.X == pt2.X </span><span class="cov0" title="0">{
                return 1000000.0
        }</span>
        <span class="cov8" title="1">return (pt2.Y - pt1.Y) / (pt2.X - pt1.X)</span>
}

// pc.Point represents a pc.Point in space.
type Size2 struct {
        deltaX float64
        deltaY float64
}

// iteroplates the position of y based on x of the location between two pc.Points
// this function accepts m the slope to keep it from recalculating
// what could be several hundred/thousand times between two pc.Points
func interp2(pt1 pc.Point, pt2 pc.Point, x float64) pc.Point <span class="cov8" title="1">{
        m := get_slope2(pt1, pt2)
        y := (x-pt1.X)*m + pt1.Y
        return pc.Point{x, y}
}</span>

type ResponseCoords2 struct {
        Coords [][][]float64 `json:"coords"`
}

// gets the coordstring into a slice the easiest way I'm aware of
func get_coords_json2(stringcoords string) [][][]float64 <span class="cov0" title="0">{
        stringcoords = fmt.Sprintf(`{"coords":%s}`, stringcoords)
        res := ResponseCoords2{}
        json.Unmarshal([]byte(stringcoords), &amp;res)

        return res.Coords
}</span>

// distance between two points
func distance_pts(oldpt pc.Point, pt pc.Point) Size2 <span class="cov8" title="1">{
        return Size2{math.Abs(pt.X - oldpt.X), math.Abs(pt.Y - oldpt.Y)}

}</span>

// distance of bounds
func distance_bounds(bds m.Extrema) Size2 <span class="cov8" title="1">{
        return Size2{bds.E - bds.W, bds.N - bds.S}
}</span>

// decides which plane something itersects with
func which_plane(oldpt pc.Point, pt pc.Point, oldbds m.Extrema) string <span class="cov8" title="1">{
        xs := []float64{oldpt.X, pt.X}
        sort.Float64s(xs)

        ys := []float64{oldpt.Y, pt.Y}
        sort.Float64s(ys)

        mybds := m.Extrema{W: xs[0], E: xs[1], S: ys[0], N: ys[1]}

        if (mybds.N &gt;= oldbds.N) &amp;&amp; (mybds.S &lt;= oldbds.N) </span><span class="cov8" title="1">{
                return "north"
        }</span><span class="cov8" title="1"> else if (mybds.N &gt;= oldbds.S) &amp;&amp; (mybds.S &lt;= oldbds.S) </span><span class="cov0" title="0">{
                return "south"
        }</span><span class="cov8" title="1"> else if (mybds.E &gt;= oldbds.E) &amp;&amp; (mybds.W &lt;= oldbds.E) </span><span class="cov8" title="1">{
                return "east"
        }</span><span class="cov8" title="1"> else if (mybds.E &gt;= oldbds.W) &amp;&amp; (mybds.W &lt;= oldbds.W) </span><span class="cov8" title="1">{
                return "west"
        }</span><span class="cov0" title="0"> else {
                return "NONE"
        }</span>
}

// given a pc.Point checks to see if the given pt is within the correct bounds
func check_bounds(oldpt pc.Point, pt pc.Point, intersectpt pc.Point, oldbds m.Extrema) bool <span class="cov0" title="0">{
        if (intersectpt.X &gt;= oldbds.W) &amp;&amp; (intersectpt.X &lt;= oldbds.E) &amp;&amp; (intersectpt.Y &gt;= oldbds.S) &amp;&amp; (intersectpt.Y &lt;= oldbds.N) &amp;&amp; (check_bb(oldpt, pt, intersectpt) == true) </span><span class="cov0" title="0">{
                //fmt.Print(check_bb(oldpt, pt, intersectpt), "\n")
                return true
        }</span><span class="cov0" title="0"> else {
                return false
        }</span>
}

// finding the pc.Point that intersects with a given y
func opp_interp(pt1 pc.Point, pt2 pc.Point, y float64) pc.Point <span class="cov8" title="1">{
        m := get_slope2(pt1, pt2)
        x := ((y - pt1.Y) / m) + pt1.X
        return pc.Point{x, y}
}</span>

// checks a boudning box
func check_bb(oldpt pc.Point, pt pc.Point, intersectpt pc.Point) bool <span class="cov0" title="0">{
        xs := []float64{oldpt.X, pt.X}
        sort.Float64s(xs)

        ys := []float64{oldpt.Y, pt.Y}
        sort.Float64s(xs)
        //fmt.Print(xs, ys, "\n")
        if (intersectpt.X &gt;= xs[0]) &amp;&amp; (intersectpt.X &lt;= xs[1]) &amp;&amp; (intersectpt.Y &gt;= ys[0]) &amp;&amp; (intersectpt.Y &lt;= ys[1]) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0"> else {
                return false
        }</span>

}

// this function gets the intersection pc.Point with a bb box
// it also returns a string of the axis it intersected with
func get_intersection_pt(oldpt pc.Point, pt pc.Point, oldbds m.Extrema) (pc.Point, string) <span class="cov0" title="0">{
        trypt := interp2(oldpt, pt, oldbds.W)
        axis := "west"
        //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)

        if check_bounds(oldpt, pt, trypt, oldbds) == false </span><span class="cov0" title="0">{
                trypt = interp2(oldpt, pt, oldbds.E)
                //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)

                axis = "east"
        }</span>
        <span class="cov0" title="0">if check_bounds(oldpt, pt, trypt, oldbds) == false </span><span class="cov0" title="0">{
                trypt = opp_interp(oldpt, pt, oldbds.S)
                //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)
                axis = "south"
        }</span>
        <span class="cov0" title="0">if check_bounds(oldpt, pt, trypt, oldbds) == false </span><span class="cov0" title="0">{
                trypt = opp_interp(oldpt, pt, oldbds.N)
                //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)

                axis = "north"
        }</span>
        <span class="cov0" title="0">if axis == "north" </span><span class="cov0" title="0">{
                trypt = pc.Point{0, 0}
        }</span>

        <span class="cov0" title="0">return trypt, axis</span>
}

// gets an intersection point
func itersection_pt(oldpt pc.Point, pt pc.Point, oldbds m.Extrema, axis string) []float64 <span class="cov8" title="1">{
        //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)
        if axis == "west" </span><span class="cov8" title="1">{
                trypt := interp2(oldpt, pt, oldbds.W)
                return []float64{trypt.X, trypt.Y}
        }</span><span class="cov8" title="1"> else if axis == "east" </span><span class="cov8" title="1">{
                trypt := interp2(oldpt, pt, oldbds.E)
                //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)
                return []float64{trypt.X, trypt.Y}

        }</span><span class="cov8" title="1"> else if axis == "south" </span><span class="cov0" title="0">{
                trypt := opp_interp(oldpt, pt, oldbds.S)
                //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)
                return []float64{trypt.X, trypt.Y}

        }</span><span class="cov8" title="1"> else if axis == "north" </span><span class="cov8" title="1">{
                trypt := opp_interp(oldpt, pt, oldbds.N)
                return []float64{trypt.X, trypt.Y}
                //fmt.Printf("%f,%f\n", trypt.X, trypt.Y)
        }</span>
        <span class="cov0" title="0">return []float64{0, 0}</span>
}

// convert the lines representing tile coods into lines readable by
// nlgeojson
func convert_tile_coords(total [][]pc.Point) <span class="cov0" title="0">{
        count := 0
        var totalstring []string
        for _, line := range total </span><span class="cov0" title="0">{
                totalstring = []string{}
                for _, pt := range line </span><span class="cov0" title="0">{
                        totalstring = append(totalstring, fmt.Sprintf("[%f,%f]", pt.X, pt.Y))
                }</span>
                //fmt.Printf(`%d,"[%s]"`, count, strings.Join(totalstring, ","))
                //fmt.Print("\n")
                <span class="cov0" title="0">count += 1</span>
        }

}

// is the number even
func Even(number int) bool <span class="cov0" title="0">{
        return number%2 == 0
}</span>

// is the number odd?
func Odd(number int) bool <span class="cov0" title="0">{
        return !Even(number)
}</span>

// gets the axis opp from the last 
// LOGIC := if were crossing one tile and going into another
// whatever plane we cross is opposite of the previous
func opp_axis(val string) string <span class="cov0" title="0">{
        if val == "north" </span><span class="cov0" title="0">{
                return "south"
        }</span><span class="cov0" title="0"> else if val == "south" </span><span class="cov0" title="0">{
                return "north"
        }</span><span class="cov0" title="0"> else if val == "west" </span><span class="cov0" title="0">{
                return "east"
        }</span><span class="cov0" title="0"> else if val == "east" </span><span class="cov0" title="0">{
                return "west"
        }</span>

        <span class="cov0" title="0">return val</span>
}

// functionifying this section so it doesnt get massive pretty decent break point
func Env_Line(line *geojson.Feature, zoom int) map[m.TileID][]*geojson.Feature <span class="cov8" title="1">{
        // intializes variables
        var oldpt pc.Point
        var tileid, oldtileid m.TileID
        var bds, oldbds m.Extrema
        var axis string
        var tilecoords [][]float64
        var intersectpt []float64
        tilemap := map[m.TileID][]*geojson.Feature{}

        // getting properties for later
        properties := line.Properties

        // iterating through each point
        ept := line.Geometry.LineString[0]
        oldpt = pc.Point{ept[0], ept[1]}
        oldtileid = m.Tile(oldpt.X, oldpt.Y, zoom)
        oldbds = m.Bounds(oldtileid)

        geoms := line.Geometry.LineString[1:]
        tilecoords = append(tilecoords, ept)

        for _, ept := range geoms </span><span class="cov8" title="1">{
                // getting pt,tileid and bounds
                pt := pc.Point{X: ept[0], Y: ept[1]}
                tileid = m.Tile(pt.X, pt.Y, zoom)
                bds = m.Bounds(tileid)

                // skipping first pt

                // shit goes down here
                // getting the distances between two coordinate points
                dist := distance_pts(oldpt, pt)

                // if the point delta we are straddling is between two tileids
                // i.e. has crossed one of planes
                if tileid != oldtileid </span><span class="cov8" title="1">{
                        bnddist := distance_bounds(bds)

                        // if one of the distances violates or is greater than the distance
                        // for bounds it will be sent into a tile creation function
                        if (bnddist.deltaX &lt; dist.deltaX) || (bnddist.deltaY &lt; dist.deltaY) </span><span class="cov0" title="0">{
                                // send to tile generation function
                                // an edge case I don't cover yet
                                //tilemap = Add_Tilemap_Segment(oldpt,pt,zoom,tilemap)
                        }</span><span class="cov8" title="1"> else {
                                // otherwise handle normally finding the intersection point and adding in the
                                // the end of tile coords
                                axis = which_plane(oldpt, pt, oldbds)
                                intersectpt = itersection_pt(oldpt, pt, oldbds, axis)
                                tilecoords = append(tilecoords, []float64{oldpt.X, oldpt.Y})

                                tilecoords = append(tilecoords, intersectpt)

                                // creating new geometry
                                newgeom := geojson.Geometry{Type: "LineString"}
                                newgeom.LineString = tilecoords
                                tilemap[oldtileid] = append(tilemap[oldtileid], &amp;geojson.Feature{Geometry: &amp;newgeom, Properties: properties})

                                // setting tile coords back to only the intersection point
                                tilecoords = [][]float64{intersectpt}

                        }</span>
                }<span class="cov8" title="1"> else {
                        tilecoords = append(tilecoords, []float64{oldpt.X, oldpt.Y})

                }</span>

                // stateful stuff
                <span class="cov8" title="1">oldpt = pt
                oldtileid = tileid
                oldbds = bds</span>
        }

        // adding the last point
        <span class="cov8" title="1">tilecoords = append(tilecoords, []float64{oldpt.X, oldpt.Y})

        // adding the last feature
        newe := geojson.Geometry{Type: "LineString"}
        newe.LineString = tilecoords
        tilemap[oldtileid] = append(tilemap[oldtileid], &amp;geojson.Feature{Geometry: &amp;newe, Properties: properties})

        return tilemap</span>
}

// translations. that probably aren't needed
func translate(val string) string <span class="cov0" title="0">{
        if "upper" == val </span><span class="cov0" title="0">{
                return "north"
        }</span><span class="cov0" title="0"> else if "lower" == val </span><span class="cov0" title="0">{
                return "south"
        }</span><span class="cov0" title="0"> else if "left" == val </span><span class="cov0" title="0">{
                return "west"
        }</span><span class="cov0" title="0"> else if "right" == val </span><span class="cov0" title="0">{
                return "east"
        }</span>
        <span class="cov0" title="0">return val</span>
}

// translations. that probably aren't needed
func opp_translate(val string) string <span class="cov0" title="0">{
        if "north" == val </span><span class="cov0" title="0">{
                return "upper"
        }</span><span class="cov0" title="0"> else if "south" == val </span><span class="cov0" title="0">{
                return "lower"
        }</span><span class="cov0" title="0"> else if "west" == val </span><span class="cov0" title="0">{
                return "left"
        }</span><span class="cov0" title="0"> else if "right" == val </span><span class="cov0" title="0">{
                return "east"
        }</span>
        <span class="cov0" title="0">return val</span>
}

func Get_string(align []pc.Point) string <span class="cov0" title="0">{
        newlist := []string{}
        for _, i := range align </span><span class="cov0" title="0">{
                newlist = append(newlist, fmt.Sprintf("[%f,%f]", i.X, i.Y))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(newlist, ","))</span>
}

// lints the children of a partmap
func Lint_Children_Lines(tilemap map[m.TileID][]*geojson.Feature, k m.TileID) map[m.TileID][]*geojson.Feature <span class="cov0" title="0">{
        childtiles := m.Children(k)
        newtilemap := map[m.TileID][]*geojson.Feature{}

        // iterating through each child
        for _, child := range childtiles </span><span class="cov0" title="0">{
                newtilemap[child] = tilemap[child]
        }</span>

        <span class="cov0" title="0">return newtilemap</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package tile_surge

import (
        "io/ioutil"
        //"sync"
        "fmt"
        "database/sql"
        _ "github.com/mattn/go-sqlite3"
        m "github.com/murphy214/mercantile"
        "encoding/json"
        "reflect"
        "github.com/paulmach/go.geojson"
        "os"
        "log"

)

var jsondata = `{
        "vector_layers": [
            {
                "id": "county",
                "description": "",
                "minzoom": 5,
                "maxzoom": 13,
                "fields": {
                    "area": "String",
                    "colorkey":"String"
                }
            }]
    }`


// vector layer json
type Vector_Layer struct {
        ID string `json:"id"`
        Description string `json:"description"`
        Minzoom int `json:"minzoom"`
        Maxzoom int `json:"maxzoom"`
        Fields map[string]string `json:"fields"`
}


type Vector_Layers struct {
        Vector_Layers []Vector_Layer `json:"vector_layers"`
}

// returns the string of the json meta data
func Make_Json_Meta(config Config,feat *geojson.Feature) string <span class="cov0" title="0">{
        layer := Vector_Layer{ID:config.Prefix,Description:"",Minzoom:config.Minzoom,Maxzoom:config.Maxzoom}

        fields := Reflect_Fields(feat.Properties)
        layer.Fields = fields

        vector_layers := Vector_Layers{Vector_Layers:[]Vector_Layer{layer}}

        b,_ := json.Marshal(vector_layers)
        return string(b)
}</span>

// creating the slice that will be used to create the metadata table
func Make_Metadata_Slice(config Config,feat *geojson.Feature) [][]string <span class="cov0" title="0">{
        // getting the json blob metadata
        jsondata := Make_Json_Meta(config,feat)

        // creating values 
        values := [][]string{{"name",config.Outputmbtilesfilename},{"type","overlay"},{"version","2"},{"description",config.Outputmbtilesfilename},{"format","pbf"},{"json",jsondata}}

        return values
}</span>

// creates the sqllite database and inserts metadata 
func Create_Database_Meta(config Config,feat *geojson.Feature) *sql.DB <span class="cov0" title="0">{
        os.Remove(config.Outputmbtilesfilename)

        db, err := sql.Open("sqlite3", config.Outputmbtilesfilename)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        //defer db.Close()
        <span class="cov0" title="0">fmt.Printf("Creating and opening %s.\n",config.Outputmbtilesfilename)


        sqlStmt := `
        CREATE TABLE metadata (name text, value text);
        `
        _, err = db.Exec(sqlStmt)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%q: %s\n", err, sqlStmt)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Created metadata table: %s.\n",config.Outputmbtilesfilename)

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">stmt, err := tx.Prepare("insert into metadata(name, value) values(?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // creating metadata slice string
        <span class="cov0" title="0">values := Make_Metadata_Slice(config,feat)


        defer stmt.Close()
        for _,i := range values </span><span class="cov0" title="0">{
                _, err = stmt.Exec(i[0],i[1])
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">tx.Commit()


        sqlStmt = `
        CREATE TABLE tiles (zoom_level integer, tile_column integer, tile_row integer, tile_data blob);
        `
        _, err = db.Exec(sqlStmt)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%q: %s\n", err, sqlStmt)
        }</span>

        <span class="cov0" title="0">tx, err = db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Inserted appropriate metadata: %s.\n",config.Outputmbtilesfilename)
        return db</span> 
}



// reflects a tile value back and stuff
func Reflect_Fields(mymap map[string]interface{}) map[string]string <span class="cov0" title="0">{
        newmap := map[string]string{}
        for k,v := range mymap </span><span class="cov0" title="0">{

                vv := reflect.ValueOf(v)
                kd := vv.Kind()
                if (reflect.Float64 == kd) || (reflect.Float32 == kd) </span><span class="cov0" title="0">{
                        //fmt.Print(v, "float", k)
                        newmap[k] = "Float"
                        //hash = Hash_Tv(tv)
                }</span><span class="cov0" title="0"> else if (reflect.Int == kd) || (reflect.Int8 == kd) || (reflect.Int16 == kd) || (reflect.Int32 == kd) || (reflect.Int64 == kd) || (reflect.Uint8 == kd) || (reflect.Uint16 == kd) || (reflect.Uint32 == kd) || (reflect.Uint64 == kd) </span><span class="cov0" title="0">{
                        //fmt.Print(v, "int", k)
                        newmap[k] = "Integer"
                        //hash = Hash_Tv(tv)
                }</span><span class="cov0" title="0"> else if reflect.String == kd </span><span class="cov0" title="0">{
                        //fmt.Print(v, "str", k)
                        newmap[k] = "String"
                        //hash = Hash_Tv(tv)

                }</span><span class="cov0" title="0"> else {
                        fmt.Print(k,v,"\n")
                }</span>
        }
        <span class="cov0" title="0">return newmap</span>
}


// inserting data into shit
func Insert_Data2(newmap map[m.TileID]Vector_Tile,db *sql.DB) *sql.DB <span class="cov0" title="0">{
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">stmt, err := tx.Prepare("insert into tiles(zoom_level, tile_column,tile_row,tile_data) values(?, ?, ?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">defer stmt.Close()
        count := 0
        total := 0
        count3 := 0


        sizenewmap := len(newmap)

        for k,v := range newmap </span><span class="cov0" title="0">{
                k.Y = (1 &lt;&lt; uint64(k.Z)) - 1 - k.Y 
                _, err = stmt.Exec(int(k.Z),int(k.X),int(k.Y),v.Data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">count += 1
                if count == 1000 </span><span class="cov0" title="0">{
                        count = 0
                        total += 1000
                        fmt.Printf("\r[%d/%d] Compressing tiles and inserting into db.",total,sizenewmap)
                }</span>

                <span class="cov0" title="0">count3 += 1</span>
                //fmt.Print(count,"\n")
                //count += 1
        }



        <span class="cov0" title="0">tx.Commit()


        return db</span>
        
}

// inserting data into shit
func Insert_Data3(newmap []Vector_Tile,db *sql.DB) *sql.DB <span class="cov0" title="0">{
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">stmt, err := tx.Prepare("insert into tiles(zoom_level, tile_column,tile_row,tile_data) values(?, ?, ?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">defer stmt.Close()
        count := 0
        total := 0
        count3 := 0


        sizenewmap := len(newmap)

        for _,v := range newmap </span><span class="cov0" title="0">{
                k := v.Tileid
                k.Y = (1 &lt;&lt; uint64(k.Z)) - 1 - k.Y 
                _, err = stmt.Exec(int(k.Z),int(k.X),int(k.Y),v.Data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">count += 1
                if count == 1000 </span><span class="cov0" title="0">{
                        count = 0
                        total += 1000
                        fmt.Printf("\r[%d/%d] Compressing tiles and inserting into db.",total,sizenewmap)
                }</span>

                <span class="cov0" title="0">count3 += 1</span>
                //fmt.Print(count,"\n")
                //count += 1
        }



        <span class="cov0" title="0">tx.Commit()


        return db</span>
        
}


func Make_Index(db *sql.DB) <span class="cov0" title="0">{
        defer db.Close()

        sqlStmt := `
        CREATE UNIQUE INDEX tile_index on tiles (zoom_level, tile_column, tile_row)
        `
        _, err := db.Exec(sqlStmt)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%q: %s\n", err, sqlStmt)
                return
        }</span>

}

// writes a json file
func Write_Json(totalmap map[m.TileID]Vector_Tile,jsonfilename string) <span class="cov0" title="0">{
        newmap := map[string][]byte{}
        for _,i := range totalmap </span><span class="cov0" title="0">{
                newmap[i.Filename] = i.Data
        }</span>

        <span class="cov0" title="0">b,_ := json.Marshal(newmap)
        ioutil.WriteFile(jsonfilename,b,0666)</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package tile_surge

// This part of the package consists of code to trim or envelope the polygons
// It also contains the subsequent code for creating polygon children.

import (
        //"fmt"
        m "github.com/murphy214/mercantile"
        pc "github.com/murphy214/polyclip"
        "github.com/paulmach/go.geojson"
        "math"
)

// function for getting the extrema of an alignment
// it also converts the points from [][][]float64 &gt; pc.Polygon
// in other words the clipping data structure
func get_extrema_coords(coords [][][]float64) (m.Extrema, pc.Polygon) <span class="cov8" title="1">{
        north := -1000.
        south := 1000.
        east := -1000.
        west := 1000.
        lat := 0.
        long := 0.
        polygon := pc.Polygon{}

        // iterating through each outer ring
        for _, coord := range coords </span><span class="cov8" title="1">{
                cont := pc.Contour{}
                // iterating through each point in a ring
                for _, i := range coord </span><span class="cov8" title="1">{
                        lat = i[1]
                        long = i[0]

                        if lat &gt; north </span><span class="cov8" title="1">{
                                north = lat
                        }</span>
                        <span class="cov8" title="1">if lat &lt; south </span><span class="cov8" title="1">{
                                south = lat
                        }</span>
                        <span class="cov8" title="1">if long &gt; east </span><span class="cov8" title="1">{
                                east = long
                        }</span>
                        <span class="cov8" title="1">if long &lt; west </span><span class="cov8" title="1">{
                                west = long
                        }</span>
                        //fmt.Print(long, lat, "\n")
                        <span class="cov8" title="1">cont.Add(pc.Point{long, lat})</span>

                }
                <span class="cov8" title="1">polygon.Add(cont)</span>
        }

        <span class="cov8" title="1">return m.Extrema{S: south, W: west, N: north, E: east}, polygon</span>

}

// gets the size of a tileid
func get_size(tile m.TileID) pc.Point <span class="cov8" title="1">{
        bds := m.Bounds(tile)
        return pc.Point{bds.E - bds.W, bds.N - bds.S}
}</span>

// raw 1d linspace like found in numpy
func linspace(val1 float64, val2 float64, number int) []float64 <span class="cov8" title="1">{
        delta := (val2 - val1) / float64(number)
        currentval := val1
        newlist := []float64{val1}
        for currentval &lt; val2 </span><span class="cov8" title="1">{
                currentval += delta
                newlist = append(newlist, currentval)
        }</span>

        <span class="cov8" title="1">return newlist</span>
}

// gets the middle of a tileid
func get_middle(tile m.TileID) pc.Point <span class="cov8" title="1">{
        bds := m.Bounds(tile)
        return pc.Point{(bds.E + bds.W) / 2.0, (bds.N + bds.S) / 2.0}
}</span>

func grid_bounds(c2pt pc.Point, c4pt pc.Point, size pc.Point) m.Extrema <span class="cov8" title="1">{
        return m.Extrema{W: c2pt.X - size.X/2.0, N: c2pt.Y + size.Y/2.0, E: c4pt.X + size.X/2.0, S: c4pt.Y - size.Y/2.0}
}</span>

// Overlaps returns whether r1 and r2 have a non-empty intersection.
func Within(big pc.Rectangle, small pc.Rectangle) bool <span class="cov8" title="1">{
        return (big.Min.X &lt;= small.Min.X) &amp;&amp; (big.Max.X &gt;= small.Max.X) &amp;&amp;
                (big.Min.Y &lt;= small.Min.Y) &amp;&amp; (big.Max.Y &gt;= small.Max.Y)
}</span>

// a check to see if each point of a contour is within the bigger
func WithinAll(big pc.Contour, small pc.Contour) bool <span class="cov8" title="1">{
        totalbool := true
        for _, pt := range small </span><span class="cov8" title="1">{
                boolval := big.Contains(pt)
                if boolval == false </span><span class="cov8" title="1">{
                        totalbool = false
                }</span>
        }
        <span class="cov8" title="1">return totalbool</span>
}

// creating a list with all of the intersecting contours
// this function returns a list of all the constituent contours as well as
// a list of their keys
func Sweep_Contmap(bb pc.Rectangle, intcont pc.Contour, contmap map[int]pc.Contour) []int <span class="cov8" title="1">{
        newlist := []int{}
        for k, v := range contmap </span><span class="cov8" title="1">{
                // getting the bounding box
                bbtest := v.BoundingBox()

                // getting within bool
                withinbool := Within(bb, bbtest)

                // logic for if within bool is true
                if withinbool == true </span><span class="cov8" title="1">{
                        withinbool = WithinAll(intcont, v)
                }</span>

                // logic for when we know the contour is within the polygon
                <span class="cov8" title="1">if withinbool == true </span><span class="cov8" title="1">{
                        newlist = append(newlist, k)
                }</span>
        }
        <span class="cov8" title="1">return newlist</span>
}

// getting the outer keys of contours that will be turned into polygons
func make_polygon_list(totalkeys []int, contmap map[int]pc.Contour, relationmap map[int][]int) []pc.Polygon <span class="cov8" title="1">{
        keymap := map[int]string{}
        for _, i := range totalkeys </span><span class="cov8" title="1">{
                keymap[i] = ""
        }</span>

        // making polygon map
        <span class="cov8" title="1">polygonlist := []pc.Polygon{}
        for k, v := range contmap </span><span class="cov8" title="1">{
                _, ok := keymap[k]
                if ok == false </span><span class="cov8" title="1">{
                        newpolygon := pc.Polygon{v}
                        otherconts := relationmap[k]
                        for _, cont := range otherconts </span><span class="cov8" title="1">{
                                newpolygon.Add(contmap[cont])
                        }</span>

                        // finally adding to list
                        <span class="cov8" title="1">polygonlist = append(polygonlist, newpolygon)</span>
                }
        }
        <span class="cov8" title="1">return polygonlist</span>

}

// creates a within map or a mapping of each edge
func Create_Withinmap(contmap map[int]pc.Contour) []pc.Polygon <span class="cov8" title="1">{
        totalkeys := []int{}
        relationmap := map[int][]int{}
        for k, v := range contmap </span><span class="cov8" title="1">{
                bb := v.BoundingBox()
                keys := Sweep_Contmap(bb, v, contmap)
                relationmap[k] = keys
                totalkeys = append(totalkeys, keys...)
        }</span>

        <span class="cov8" title="1">return make_polygon_list(totalkeys, contmap, relationmap)</span>
}

// lints each polygon
// takes abstract polygon rings that may contain polygon rings
// and returns geojson arranged polygon sets
func Lint_Polygons(polygon pc.Polygon) []pc.Polygon <span class="cov8" title="1">{
        contmap := map[int]pc.Contour{}
        for i, cont := range polygon </span><span class="cov8" title="1">{
                contmap[i] = cont
        }</span>
        <span class="cov8" title="1">return Create_Withinmap(contmap)</span>

}

// from a pc.Polygon representation (clipping representation)
// to a [][][]float64 representation
func Convert_Float(poly pc.Polygon) [][][]float64 <span class="cov8" title="1">{
        total := [][][]float64{}
        for _, cont := range poly </span><span class="cov8" title="1">{
                contfloat := [][]float64{}
                for _, pt := range cont </span><span class="cov8" title="1">{
                        contfloat = append(contfloat, []float64{pt.X, pt.Y})
                }</span>
                <span class="cov8" title="1">total = append(total, contfloat)</span>
        }
        <span class="cov8" title="1">return total</span>
}

// output structure to ensure everything stays in a key value stroe
type Output struct {
        Total [][][][]float64
        ID    m.TileID
}

// given a polygon to be tiled envelopes the polygon in corresponding boxes
func Env_Polygon(polygon *geojson.Feature, size int) map[m.TileID][]*geojson.Feature <span class="cov8" title="1">{
        // getting bds
        bds, poly := get_extrema_coords(polygon.Geometry.Polygon)

        // dummy values you know
        intval := 0
        tilemap := map[m.TileID][]int{}

        // getting all four corners
        c1 := pc.Point{bds.E, bds.N}
        c2 := pc.Point{bds.W, bds.N}
        c3 := pc.Point{bds.W, bds.S}
        c4 := pc.Point{bds.E, bds.S}

        // getting all the tile corners
        c1t := m.Tile(c1.X, c1.Y, size)
        c2t := m.Tile(c2.X, c2.Y, size)
        c3t := m.Tile(c3.X, c3.Y, size)
        c4t := m.Tile(c4.X, c4.Y, size)

        //tilemap := map[m.TileID][]int32{}
        tilemap[c1t] = append(tilemap[c1t], intval)
        tilemap[c2t] = append(tilemap[c2t], intval)
        tilemap[c3t] = append(tilemap[c3t], intval)
        tilemap[c4t] = append(tilemap[c4t], intval)
        sizetile := get_size(c1t)

        //c1pt := get_middle(c1t)
        c2pt := get_middle(c2t)
        //c3pt := get_middle(c3t)
        c4pt := get_middle(c4t)

        gridbds := grid_bounds(c2pt, c4pt, sizetile)
        //fmt.Print(gridbds, sizetile, "\n")
        sizepoly := pc.Point{bds.E - bds.W, bds.N - bds.S}
        xs := []float64{}
        if c2pt.X == c4pt.X </span><span class="cov0" title="0">{
                xs = []float64{c2pt.X}
        }</span><span class="cov8" title="1"> else {
                xs = []float64{c2pt.X, c4pt.X}

        }</span>
        <span class="cov8" title="1">ys := []float64{}
        if c2pt.Y == c4pt.Y </span><span class="cov0" title="0">{
                ys = []float64{c2pt.Y}
        }</span><span class="cov8" title="1"> else {
                ys = []float64{c2pt.Y, c4pt.Y}

        }</span>
        <span class="cov8" title="1">if sizetile.X &lt; sizepoly.X </span><span class="cov8" title="1">{
                number := int((gridbds.E - gridbds.W) / sizetile.X)
                xs = linspace(gridbds.W, gridbds.E, number+1)
        }</span>
        <span class="cov8" title="1">if sizetile.Y &lt; sizepoly.Y </span><span class="cov8" title="1">{
                number := int((gridbds.N - gridbds.S) / sizetile.Y)
                ys = linspace(gridbds.S, gridbds.N, number+1)
        }</span>

        //totallist := []string{}

        <span class="cov8" title="1">for _, xval := range xs </span><span class="cov8" title="1">{
                // iterating through each y
                for _, yval := range ys </span><span class="cov8" title="1">{
                        tilemap[m.Tile(xval, yval, size)] = append(tilemap[m.Tile(xval, yval, size)], intval)
                }</span>
        }
        <span class="cov8" title="1">c := make(chan Output)
        for k := range tilemap </span><span class="cov8" title="1">{
                newpoly := poly
                go func(newpoly pc.Polygon, k m.TileID, c chan Output) </span><span class="cov8" title="1">{
                        newpoly2 := newpoly.Construct(pc.INTERSECTION, Make_Tile_Poly(k))
                        polys := Lint_Polygons(newpoly2)
                        total := [][][][]float64{}
                        for _, p := range polys </span><span class="cov8" title="1">{
                                total = append(total, Convert_Float(p))

                        }</span>
                        <span class="cov8" title="1">c &lt;- Output{Total: total, ID: k}</span>
                }(newpoly, k, c)
        }
        <span class="cov8" title="1">totalmap := map[m.TileID][]*geojson.Feature{}
        properties := polygon.Properties
        for range tilemap </span><span class="cov8" title="1">{
                output := &lt;-c
                if len(output.Total) &gt; 0 </span><span class="cov8" title="1">{
                        for _, coord := range output.Total </span><span class="cov8" title="1">{
                                newgeom := geojson.Geometry{Type: "Polygon"}
                                newgeom.Polygon = coord
                                newfeat := geojson.Feature{Geometry: &amp;newgeom, Properties: properties}
                                totalmap[output.ID] = append(totalmap[output.ID], &amp;newfeat)
                        }</span>
                }
        }

        <span class="cov8" title="1">return totalmap</span>

}

// makes the tile polygon
func Make_Tile_Poly(tile m.TileID) pc.Polygon <span class="cov8" title="1">{
        bds := m.Bounds(tile)
        return pc.Polygon{{pc.Point{bds.E, bds.N}, pc.Point{bds.W, bds.N}, pc.Point{bds.W, bds.S}, pc.Point{bds.E, bds.S}}}
}</span>

// area of bds (of a square)
func AreaBds(ext m.Extrema) float64 <span class="cov8" title="1">{
        return (ext.N - ext.S) * (ext.E - ext.W)
}</span>

// given a polygon to be tiled envelopes the polygon in corresponding boxes
// from a polygon and a tileid return the tiles relating to the polygon 1 level lower
func Children_Polygon(polygon *geojson.Feature, tileid m.TileID) map[m.TileID][]*geojson.Feature <span class="cov8" title="1">{
        // getting bds
        bd, poly := get_extrema_coords(polygon.Geometry.Polygon)
        pt := poly[0][0]

        temptileid := m.Tile(pt.X, pt.Y, int(tileid.Z+1))
        bdtemp := m.Bounds(temptileid)

        // checking to see if the polygon lies entirely within a smaller childd
        if (bd.N &lt;= bdtemp.N) &amp;&amp; (bd.S &gt;= bdtemp.S) &amp;&amp; (bd.E &lt;= bdtemp.E) &amp;&amp; (bd.W &gt;= bdtemp.W) </span><span class="cov8" title="1">{
                totalmap := map[m.TileID][]*geojson.Feature{}
                totalmap[temptileid] = append(totalmap[temptileid], polygon)
                return totalmap
        }</span>

        // checking to see if the polygon is encompassed within a square
        <span class="cov8" title="1">bdtileid := m.Bounds(tileid)
        if (math.Abs(AreaBds(bdtileid)-AreaBds(bd)) &lt; math.Pow(.000001,2.0)) &amp;&amp; len(poly) == 1 &amp;&amp; len(poly[0]) == 4 </span><span class="cov8" title="1">{
                //fmt.Print("here\n")
                totalmap := map[m.TileID][]*geojson.Feature{}

                tiles := m.Children(tileid)
                for _, k := range tiles </span><span class="cov8" title="1">{
                        //poly := Make_Tile_Poly(k)
                        bds := m.Bounds(k)
                        poly := [][][]float64{{{bds.E, bds.N}, {bds.W, bds.N}, {bds.W, bds.S}, {bds.E, bds.S}}}
                        newgeom := geojson.Geometry{Type: "Polygon", Polygon: poly}

                        totalmap[k] = append(totalmap[k], &amp;geojson.Feature{Geometry: &amp;newgeom, Properties: polygon.Properties})
                }</span>

                <span class="cov8" title="1">return totalmap</span>

        }

        //fmt.Print("\r", len(polygon.Geometry.Polygon[0]))

        <span class="cov8" title="1">c := make(chan Output)
        // creating the 4 possible children tiles
        // and sending into a go function
        tiles := m.Children(tileid)
        for _, k := range tiles </span><span class="cov8" title="1">{
                newpoly := poly
                go func(newpoly pc.Polygon, k m.TileID, c chan Output) </span><span class="cov8" title="1">{
                        newpoly2 := newpoly.Construct(pc.INTERSECTION, Make_Tile_Poly(k))
                        polys := Lint_Polygons(newpoly2)
                        total := [][][][]float64{}
                        for _, p := range polys </span><span class="cov8" title="1">{
                                total = append(total, Convert_Float(p))

                        }</span>
                        <span class="cov8" title="1">c &lt;- Output{Total: total, ID: k}</span>
                }(newpoly, k, c)
        }
        <span class="cov8" title="1">totalmap := map[m.TileID][]*geojson.Feature{}
        properties := polygon.Properties
        for range tiles </span><span class="cov8" title="1">{
                output := &lt;-c
                if len(output.Total) &gt; 0 </span><span class="cov8" title="1">{
                        for _, coord := range output.Total </span><span class="cov8" title="1">{
                                newgeom := geojson.Geometry{Type: "Polygon"}
                                newgeom.Polygon = coord
                                newfeat := geojson.Feature{Geometry: &amp;newgeom, Properties: properties}
                                totalmap[output.ID] = append(totalmap[output.ID], &amp;newfeat)
                        }</span>
                }
        }

        <span class="cov8" title="1">return totalmap</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package tile_surge

import (
        m "github.com/murphy214/mercantile"
        "github.com/paulmach/go.geojson"
        "os"
        "strconv"
        "vector-tile/2.1"
        "github.com/golang/protobuf/proto"
        "reflect"
        "sync"
)

var dirmap sync.Map

// reflects a tile value back and stuff
func Reflect_Value(v interface{}) *vector_tile.Tile_Value <span class="cov8" title="1">{
        var tv *vector_tile.Tile_Value
        //fmt.Print(v)
        vv := reflect.ValueOf(v)
        kd := vv.Kind()
        if (reflect.Float64 == kd) || (reflect.Float32 == kd) </span><span class="cov8" title="1">{
                //fmt.Print(v, "float", k)
                tv = Make_Tv_Float(float64(vv.Float()))
                //hash = Hash_Tv(tv)
        }</span><span class="cov8" title="1"> else if (reflect.Int == kd) || (reflect.Int8 == kd) || (reflect.Int16 == kd) || (reflect.Int32 == kd) || (reflect.Int64 == kd) || (reflect.Uint8 == kd) || (reflect.Uint16 == kd) || (reflect.Uint32 == kd) || (reflect.Uint64 == kd) </span><span class="cov8" title="1">{
                //fmt.Print(v, "int", k)
                tv = Make_Tv_Int(int(vv.Int()))
                //hash = Hash_Tv(tv)
        }</span><span class="cov8" title="1"> else if reflect.String == kd </span><span class="cov8" title="1">{
                //fmt.Print(v, "str", k)
                tv = Make_Tv_String(string(vv.String()))
                //hash = Hash_Tv(tv)

        }</span><span class="cov0" title="0"> else {
                tv := new(vector_tile.Tile_Value)
                t := ""
                tv.StringValue = &amp;t
        }</span>
        <span class="cov8" title="1">return tv</span>
}

// makes a tile_value string
func Make_Tv_String(stringval string) *vector_tile.Tile_Value <span class="cov8" title="1">{
        tv := new(vector_tile.Tile_Value)
        t := string(stringval)
        tv.StringValue = &amp;t
        return tv
}</span>

// makes a tile value float
func Make_Tv_Float(val float64) *vector_tile.Tile_Value <span class="cov8" title="1">{
        tv := new(vector_tile.Tile_Value)
        t := float64(val)
        tv.DoubleValue = &amp;t
        return tv
}</span>

// makes a tile value int
func Make_Tv_Int(val int) *vector_tile.Tile_Value <span class="cov8" title="1">{
        tv := new(vector_tile.Tile_Value)
        t := int64(val)
        tv.SintValue = &amp;t
        return tv
}</span>

// updates all values and tags
// handles 4 objects keys,values,keymap,valuesmap
// also returns tags
func Update_Properties(properties map[string]interface{}, keys []string, values []*vector_tile.Tile_Value, keysmap map[string]uint32, valuesmap map[*vector_tile.Tile_Value]uint32) ([]uint32, []string, []*vector_tile.Tile_Value, map[string]uint32, map[*vector_tile.Tile_Value]uint32) <span class="cov8" title="1">{
        tags := []uint32{}
        // iterating through each property
        for k, v := range properties </span><span class="cov8" title="1">{
                value := Reflect_Value(v)

                // logic for keys
                keyint, keybool := keysmap[k]
                if keybool == false </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                        keysmap[k] = uint32(len(keys) - 1)
                        tags = append(tags, uint32(len(keys)-1))
                }</span><span class="cov0" title="0"> else {
                        tags = append(tags, keyint)
                }</span>

                // logic for keys
                <span class="cov8" title="1">valueint, valuebool := valuesmap[value]
                if valuebool == false </span><span class="cov8" title="1">{
                        values = append(values, value)
                        valuesmap[value] = uint32(len(values) - 1)
                        tags = append(tags, uint32(len(values)-1))
                }</span><span class="cov0" title="0"> else {
                        tags = append(tags, valueint)
                }</span>

        }

        <span class="cov8" title="1">return tags, keys, values, keysmap, valuesmap</span>
}

type Properties_Config struct {
        Keys        []string
        KeysCount   uint32
        Values      []*vector_tile.Tile_Value
        ValuesCount uint32
        KeysMap     sync.Map
        ValuesMap   sync.Map
}

// updates all values and tags
// handles 4 objects keys,values,keymap,valuesmap
// also returns tags
func Update_Properties2(properties map[string]interface{}, prop Properties_Config) ([]uint32, Properties_Config) <span class="cov0" title="0">{
        tags := []uint32{}
        // iterating through each property
        for k, v := range properties </span><span class="cov0" title="0">{
                value := Reflect_Value(v)

                // logic for keys
                keyint, keybool := prop.KeysMap.LoadOrStore(k, prop.KeysCount)
                if keybool == false </span><span class="cov0" title="0">{
                        prop.Keys = append(prop.Keys, k)
                        tags = append(tags, prop.KeysCount)
                        prop.KeysCount += 1

                }</span><span class="cov0" title="0"> else {
                        //eh := keyint.(int)
                        eh, _ := keyint.(uint32) // Alt. non panicking version

                        tags = append(tags, eh)
                }</span>
                // logic for keys
                <span class="cov0" title="0">valueint, valuebool := prop.KeysMap.LoadOrStore(k, prop.KeysCount)
                if valuebool == false </span><span class="cov0" title="0">{
                        prop.Values = append(prop.Values, value)
                        tags = append(tags, prop.ValuesCount)
                        prop.ValuesCount += 1

                }</span><span class="cov0" title="0"> else {
                        eh, _ := valueint.(uint32) // Alt. non panicking version

                        tags = append(tags, eh)
                }</span>
        }

        <span class="cov0" title="0">return tags, prop</span>
}

// makes a single tile for a given polygon
func Make_Tile(tileid m.TileID, feats []*geojson.Feature, prefix string,config Config) Vector_Tile <span class="cov8" title="1">{

        filename := prefix + "/" + strconv.Itoa(int(tileid.Z)) + "/" + strconv.Itoa(int(tileid.X)) + "/" + strconv.Itoa(int(tileid.Y))
        dir := prefix + "/" + strconv.Itoa(int(tileid.Z)) + "/" + strconv.Itoa(int(tileid.X))
        
        if config.Type == "files" </span><span class="cov0" title="0">{
                os.MkdirAll(dir, os.ModePerm)
        }</span>

        // intializing shit for cursor
        <span class="cov8" title="1">bound := m.Bounds(tileid)
        deltax := bound.E-bound.W
        deltay := bound.N - bound.S

        var keys []string
        var values []*vector_tile.Tile_Value
        keysmap := map[string]uint32{}
        valuesmap := map[*vector_tile.Tile_Value]uint32{}

        // iterating through each feature
        features := []*vector_tile.Tile_Feature{}
        
        // setting and converting coordinate        
        cur := Cursor{LastPoint:[]int32{0,0},Bounds:bound,DeltaX:deltax,DeltaY:deltay,Count:0}
        cur = Convert_Cursor(cur)

        //position := []int32{0, 0}
        for _, i := range feats </span><span class="cov8" title="1">{
                // creating cursor used in geometry creation

                var tags, geometry []uint32
                var feat vector_tile.Tile_Feature
                tags, keys, values, keysmap, valuesmap = Update_Properties(i.Properties, keys, values, keysmap, valuesmap)

                // logic for point feature
                if i.Geometry.Type == "Point" </span><span class="cov0" title="0">{
                        geometry = cur.Make_Point_Float(i.Geometry.Point)
                        feat_type := vector_tile.Tile_POINT
                        feat = vector_tile.Tile_Feature{Tags: tags, Type: &amp;feat_type, Geometry: geometry}
                        features = append(features, &amp;feat)

                }</span><span class="cov8" title="1"> else if i.Geometry.Type == "LineString" </span><span class="cov0" title="0">{
                        if len(i.Geometry.LineString) &gt;= 2 </span><span class="cov0" title="0">{
                                geometry = cur.Make_Line_Float(i.Geometry.LineString)
                                if geometry[3] &gt; 2 </span><span class="cov0" title="0">{
                                        feat_type := vector_tile.Tile_LINESTRING
                                        feat = vector_tile.Tile_Feature{Tags: tags, Type: &amp;feat_type, Geometry: geometry}
                                        features = append(features, &amp;feat)
                                }</span>

                        }
                }<span class="cov8" title="1"> else if i.Geometry.Type == "Polygon" </span><span class="cov8" title="1">{
                        geometry = cur.Make_Polygon_Float(i.Geometry.Polygon)
                        feat_type := vector_tile.Tile_POLYGON
                        feat = vector_tile.Tile_Feature{Tags: tags, Type: &amp;feat_type, Geometry: geometry}
                        features = append(features, &amp;feat)

                }</span>

        }

        <span class="cov8" title="1">layerVersion := uint32(15)
        extent := vector_tile.Default_Tile_Layer_Extent
        //var bound []Bounds
        layername := prefix
        layer := vector_tile.Tile_Layer{
                Version:  &amp;layerVersion,
                Name:     &amp;layername,
                Extent:   &amp;extent,
                Values:   values,
                Keys:     keys,
                Features: features,
        }

        tile := vector_tile.Tile{}
        tile.Layers = append(tile.Layers, &amp;layer)
        bytevals,_ := proto.Marshal(&amp;tile)

        return Vector_Tile{Data:bytevals,Filename:filename,Tileid:tileid}</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tile_surge 

import (
        "fmt"
        "github.com/paulmach/go.geojson"
        "strings"
        "reflect"
        m "github.com/murphy214/mercantile"
)

// tilemap feature
func Feature_String(a *geojson.Feature) string <span class="cov0" title="0">{
        var geom string
        if a.Geometry.Type == "LineString" </span><span class="cov0" title="0">{
                eh := fmt.Sprintf("%v",a.Geometry.LineString)
                eh = strings.Replace(eh,"[","{",1000000000)
                eh = strings.Replace(eh,"]","}",1000000000)
                eh = strings.Replace(eh," ",",",1000000000)
                geom = fmt.Sprintf(`&amp;geojson.Geometry{LineString:[][]float64%s,Type:"Linestring"}`,eh)
                
        }</span><span class="cov0" title="0"> else if a.Geometry.Type == "Polygon" </span><span class="cov0" title="0">{
                eh := fmt.Sprintf("%v",a.Geometry.Polygon)
                eh = strings.Replace(eh,"[","{",1000000000)
                eh = strings.Replace(eh,"]","}",1000000000)
                eh = strings.Replace(eh," ",",",1000000000)
                geom = fmt.Sprintf(`&amp;geojson.Geometry{Polygon:[][][]float64%s,Type:"Polygon"}`,eh)
                
        }</span>
        <span class="cov0" title="0">newmap := map[string]interface{}{}
        for k,v := range a.Properties </span><span class="cov0" title="0">{
                vv := reflect.ValueOf(v)
                kd := vv.Kind()
                if kd == reflect.String </span><span class="cov0" title="0">{
                        stringval := `"` + v.(string) + `"`
                        v = reflect.ValueOf(stringval)
                        //v = stringval.(interface{}) 
                }</span>

                <span class="cov0" title="0">newmap[`"`+k+`"`] = v</span>
        }

        <span class="cov0" title="0">shit := fmt.Sprintf("%v",newmap)
        shit = shit[4:len(shit)-1]
        shit = "{" + shit + "}"
        shit = strings.Replace(shit," ",`,`,1000000000)
        shit = fmt.Sprintf("map[string]interface{}%s",shit)
        //fmt.Print(shit,"\n")
        total := fmt.Sprintf("&amp;geojson.Feature{Geometry:%s,Properties:%s}",geom,shit)
        //fmt.Print(total,"\n")
        return total</span>
}

// takes a raw tilemap and returns a string that can be 
// palced within a line of code or test
func Tilemap_String(tilemap map[m.TileID][]*geojson.Feature) string <span class="cov0" title="0">{

        newmap := map[m.TileID]string{}
        for k,v := range tilemap </span><span class="cov0" title="0">{
                stringlist := []string{}
                for _,i := range v </span><span class="cov0" title="0">{
                        stringlist = append(stringlist,Feature_String(i))
                }</span>
                <span class="cov0" title="0">shit :=fmt.Sprintf("[]*geojson.Feature{%s}",strings.Join(stringlist,","))
                newmap[k] = shit</span>
        }


        <span class="cov0" title="0">shit := fmt.Sprintf("%v",newmap)
        shit = shit[4:len(shit)-1]
        shit = "{" + shit + "}"
        shit = strings.Replace(shit," ",`,`,1000000000)
        shit = "map[m.TileID][]*geojson.Feature" + shit

        return shit</span>
        //shit = fmt.Sprintf("map[m.TileID][]{}%s",shit)

}

// makes a feature string list
func FeatureStringList(v []*geojson.Feature) string <span class="cov0" title="0">{

        stringlist := []string{}
        for _,i := range v </span><span class="cov0" title="0">{
                stringlist = append(stringlist,Feature_String(i))
        }</span>
        <span class="cov0" title="0">shit :=fmt.Sprintf("[]*geojson.Feature{%s}",strings.Join(stringlist,","))
        return shit</span>

}

// creates a vector tile string
func VectorTileString(vt Vector_Tile) string <span class="cov0" title="0">{
        eh := fmt.Sprintf("%+v",vt.Data)
        eh = strings.Replace(eh," ",",",10000000000)
        eh = "Data:[]byte{" + eh[1:len(eh)-1] + "}"
        eh2 := fmt.Sprintf(`Filename:"%s"`,vt.Filename)

        eh3 := fmt.Sprintf("Tileid:m.TileID%+v",vt.Tileid)
        eh3 = strings.Replace(eh3," ",",",10000000)
        stringvals := []string{eh,eh2,eh3}

        totalstring := strings.Join(stringvals,",")
        totalstring = fmt.Sprintf("Vector_Tile{%s}",totalstring)
        return totalstring
}</span>

// creates a vector tile string list
func VectorTileListString(vts []Vector_Tile) string <span class="cov0" title="0">{
        newlist := []string{}
        for _,i := range vts </span><span class="cov0" title="0">{
                newlist = append(newlist,VectorTileString(i))
        }</span>

        <span class="cov0" title="0">totalstring := strings.Join(newlist,",")
        totalstring = fmt.Sprintf("[]Vector_Tile{%s}",totalstring)
        return totalstring</span>
}


func TileIDString(tileid m.TileID) string <span class="cov0" title="0">{
        tilestr := fmt.Sprintf("%+v",tileid)
        tilestr = strings.Replace(tilestr," ",",",1000000)
        tilestr = fmt.Sprintf("m.TileID%s",tilestr)
        return tilestr
}</span>


func TileListString(tileids []m.TileID) string <span class="cov0" title="0">{
        totalstring := []string{}
        for _,i := range tileids </span><span class="cov0" title="0">{
                totalstring = append(totalstring,TileIDString(i))
        }</span>

        <span class="cov0" title="0">totalstr := strings.Join(totalstring,",")
        return fmt.Sprintf("[]m.TileID{%s}",totalstr)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
